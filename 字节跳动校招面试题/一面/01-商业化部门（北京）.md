# 一、7层网络模型，每一层有哪些协议，问的比较细
解析：7层网络模型是**物理层**、**数据链路层**、**网络层**、**传输层**、**会话层**、**表示层**和**应用层**。
- 物理层：有关传输介质的特性，常用的规范有**RJ45**,**802.3**。
- 数据链路层：将原始比特流转变为逻辑传输线路。**ATM**，**FDDI**。
- 网络层：定义IP编址，路由选择和分组转发，**IP**。
- 传输层：负责两个进程之间的逻辑通信**TCP**，**UDP**。
- 会话层：不同机器上的用户之间建立及管理会话。
- 表示层：信息的语法语义以及它们的关联，如加密解密、转换翻译、压缩解压缩。
- 应用层：各种应用层协议，如HTTP、FTP、SMTP、POP3协议。
  ![网络模型](https://user-images.githubusercontent.com/72426886/132125444-49299b48-ee8a-42f5-90c6-464ea47e10e0.png)
# 二、Leetcode买卖股票的最佳时机
## 2.1 只能买卖一次（121）

输入：[7,1,5,3,6,4]
输出：5
> 一次遍历，记录最小值，同时把每个数和最小值的差和maxProfit作比较，取最大值。
```js
/**
 * @param {number[]} prices
 * @return {number}
 */
const maxProfit = function(prices) {
    let n = prices.length
    let profit_out = 0
    let profit_in = -prices[0]
    for (let i = 1; i < n; i++) {
        profit_out = Math.max(profit_out, profit_in + prices[i])
        profit_in = Math.max(profit_in,  -prices[i])
    }
    return profit_out
}
```
## 2.2 可以买卖无数次（122）
输入: prices = [7,1,5,3,6,4]
输出: 7
> 遍历输入的股价，若第i天的价格比第i-1天的价格高，那么我们就将第i天的价格差计入我们的总利润中，直到列表遍历结束

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit1 = function(prices) {
  let len = prices.length
    let profit = 0
    for(let i = 0; i < len ; i++){
        if(prices[i] > prices[i-1]){
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
};
const maxProfit2 = function(prices) {
    let n = prices.length
    let profit_out = 0
    let profit_in = -prices[0]
    for (let i = 1; i < n; i++) {
        profit_out = Math.max(profit_out, profit_in + prices[i])
        profit_in = Math.max(profit_in, profit_out - prices[i])
    }
    return profit_out
}

```
## 2.3 最多可以买卖k次

> 动态规划，一个动态方程求解所有股票买卖问题。

### （1）暴力解法
### （2）dp 两步曲
1. 状态的定义
   MP[i][k][j]： 到了第i天的maxProfit, 
   i的范围: 0 ~ n-1  
   j的范围:  0(没有股票) , 1（有股票） 
   k的范围：之前交易的次数0 ~ k
   MP[i][k][0] = Max(MP[i-1][k][0], MP[i-1][k][1] + prices[i])

   MP[i][k][1] = Max(MP[i-1][k][1], MP[i-1][k-1][0] - prices[i])

   最后的结果：Max(MP[n-1,{0~k},0])
```js
const maxProfit = function(k, prices) {
    let n = prices.length
    const maxProfit2 = function(prices) {
        let profit_out = 0
        let profit_in = -prices[0]
        for (let i = 1; i < n; i++) {
            profit_out = Math.max(profit_out, profit_in + prices[i])
            profit_in = Math.max(profit_in, profit_out - prices[i])
        }
        return profit_out
    }
    if (k > n / 2) {
        return maxProfit2(prices)
    }
    let profit = new Array(k)
    // 初始化买入卖出时的利润，将每次交易买入、卖出时的利润放在一个对象中，实现降维
    for (let j = 0; j <= k; j++) {
        profit[j] = {
            profit_in: -prices[0],
            profit_out: 0
        }
    }
    for (let i = 0; i < n; i++) {
        for (let j = 1; j <= k; j++) {
            profit[j] = {
                profit_out: Math.max(profit[j].profit_out, profit[j].profit_in + prices[i]), 
                profit_in: Math.max(profit[j].profit_in, profit[j-1].profit_out - prices[i])
            }
        }
    }
    return profit[k].profit_out
}
```
## 2.4 最多可以买卖两次
```js
const maxProfit = function(prices) {
    let profit_1_in = -prices[0], profit_1_out = 0
    let profit_2_in = -prices[0], profit_2_out = 0
    let n = prices.length
    for (let i = 1; i < n; i++) {
        profit_2_out = Math.max(profit_2_out, profit_2_in + prices[i])
        profit_2_in = Math.max(profit_2_in, profit_1_out - prices[i])
        profit_1_out = Math.max(profit_1_out, profit_1_in + prices[i])
        profit_1_in = Math.max(profit_1_in, -prices[i])
    }
    return profit_2_out
}

```
## 2.5 k为无穷但有冷却时间
```js

const maxProfit = function(prices) {
    let n = prices.length
    let profit_in = -prices[0]
    let profit_out = 0
    let profit_freeze = 0
    for (let i = 1; i < n; i++) {
        let temp = profit_out
        profit_out = Math.max(profit_out, profit_in + prices[i])
        profit_in = Math.max(profit_in, profit_freeze - prices[i])
        profit_freeze = temp
    }
    return profit_out
}

```
## 2.6 k为正无穷但有手续费
```js
const maxProfit = function(prices, fee) {
    let profit_out = 0
    let profit_in = -prices[0]
    for (let i = 1; i < prices.length; i++) {
        profit_out = Math.max(profit_out, profit_in + prices[i] - fee)
        profit_in = Math.max(profit_in, profit_out - prices[i])
    }
    return profit_out
}
```
# 三、实现Promise.all
解析：
对于all方法而言，需要完成的核心功能：
- 传入一个空的可迭代对象则直接**resolve**。
- 如果参数中`有一个`Promise失败，那么Promise.all返回的Promise对象失败。
- 在任何情况下，Promise.all返回的Promise的完成状态的结果都是一个数组
```js
Promise.all = function(promise){
  return new Promise((resolve,reject)=>{
    let result = []
    let index = 0
    let len = promise.length
    if(len === 0){
      resolve(result)
      return
    }
    for(let i = 0; i < len; i++){
      Promise.resolve(promise[i]).then(data=>{
        result[i] = data
        index++
        if(index === len) resolve(result)
      }).catch(err=>{
        reject(err)
      })
    }
  })
}
```
### 实现Promise.race（附加餐）
```js
Promise.race = function(promise){
  return new Promsie((resolve,rejecct) => {
    let len = promise.length
    if(len === 0) return
    for(let i = 0; i < len; i++){
      Promise.resolve(promise[i]).then(data => {
        resolve(data)
        return
      }).catch(err=>{
        return
      })
    }
  })
}
```