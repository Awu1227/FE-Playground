# 垃圾回收
> 在程序中，有些数据被使用之后，可能就不再需要了，我们把这种数据称为**垃圾数据**，如果垃圾数据一直保存在内存中那么内存会越用越多，所以我们需要**对这些数据进行垃圾回收，以释放有限地内存空间**。
## 不同语言的垃圾回收策略
> 通常情况下，垃圾数据回收分为**手动回收**和**自动回收**两种策略。

如C/C++就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，在C中，我们需要调用**mallco函数**分配内存空间，然后再使用；当不再需要这块数据的时候，就要手动调用**free函数**来释放内存，如果没有主动调用free函数来销毁，这种情况就被称为**内存泄漏**。

JavaScript、Java、Python等语言都会采用自动垃圾回收的策略，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。

接下来我们就来谈谈在JS中，“栈中的垃圾数据”和“堆中的垃圾数据”时如何回收的。看下面这段代码：
## 调用栈中的数据是如何回收的
```js

function foo(){
    var a = 1
    var b = {name:"橙子"}
    function showName(){
      var c = 2
      var d = {name:"柚子"}
    }
    showName()
}
foo()
```
执行这段代码，原始类型的数据会被分配到栈中，引用类型会被分配到堆中，当foo函数执行结束之后，foo函数的执行上下文会从堆中被销毁掉，它是怎么被销毁的呢？

销毁操作是靠ESP（**记录当前执行状态的指针**）实现的，当showName函数执行完成后，于是函数执行流程进入了foo函数，这个时候**ESP**指针也就从showName函数执行上下文下移到foo函数的执行上下文，这个**下移操作**就是销毁了showName函数执行上下文的过程。

## 堆中的数据是如何回收的

> **要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了**。

### 代际假说和分代收集
> 在将V8如何实现回收之前，需要学习一下**代际假说**的内容，这是垃圾回收邻域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础上，所以非常重要。

代际假说有两个特点：

1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。

2. 第二个是不死的对象，会活的更久。

> 垃圾回收算法有很多，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。

在V8这会把堆分为**新生代**和**老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收：

- 副垃圾回收器：负责新生代区域的垃圾回收。
- 主垃圾回收器：负责老生代的垃圾回收。

### 垃圾回收器的工作流程

1. 标记空间中活动对象和非活动对象。活动对象即还在使用的对象，非活动对象就是可以进行垃圾回收对象。

2. 回收非活动对象所占据的内存。

3. 内存整理，频繁回收对象后，内存中就会存在大量不连续空间，也称其为**内存碎片**。当内存中出现大量内存碎片后，如果需要较大连续内存的时候，有可能会出现内存不足的情况，所以需要内存整理，当然这一步也是可选的，副垃圾回收器并不会产生内存碎片。

> 我们就按照这个流程来分析副垃圾回收器和主垃圾回收器是如何处理垃圾回收的。

### 副垃圾回收器
大多数小的对象会被分配到新生代区域，这个区域垃圾回收还是比较频繁的。
> 新生代中用Scavenge算法来处理，把新生代空间对半划分为两个区域，一半是对象区域，另一半是空闲区域，如下图：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4e363ddcf0244d9ac32828dd75a3518~tplv-k3u1fbpfcp-watermark.image)

新写入的对象会被存放到**对象区域**，当**对象区域**快被写满时，就需要执行一次垃圾清理操作。

1. 标记阶段
2. 垃圾清理阶段，副垃圾回收器会把存活的对象复制到空闲区域中。
3. 内存整理阶段，把这些对象有序地排列起来
4. 翻转阶段，**对象区域**与**空闲区域**翻转

这样就完成了垃圾对象的回收操作，同时这种**角色翻转的操作还能让新生代中这两块区域无限重复下去。**

> Scavenge算法中，为了执行效率，一般新生区空间会被设置得比较小。

> 由于新生区空间不大，存活的对象容易装满整个区域，JS引擎为了解决这个问题采用了对象晋升策略，经过两次垃圾回收依然存活的对象，会被移动到老生区。

### 主垃圾回收器
> 主垃圾回收器采用**标记-清除**算法进行垃圾回收的

1. 标记过程阶段，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素可以判断为**垃圾数据**。

2. 清除阶段，清除掉被标记的垃圾数据

> 由于标记-清除算法对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。为了解决这个问题又产生了**标记-整理**算法，这个步骤和标记-清除算法类似，只是后续步骤上不一样，标记-整理算法是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
### 增量标记算法
> 由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，然后需要将JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做**全停顿**。这样非常容易造成页面的卡顿，为了降低老生代垃圾回收而造成的卡顿，出现了增量标记算法，V8将标记过程分为一个个的子标记过程，同时让子标记过程和JavaScript应用逻辑交替，直到标记阶段完成。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/745587735ca84d2bbd14b09ac0f89229~tplv-k3u1fbpfcp-watermark.image)
使用增量标记算法，把整个垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，穿插在其他JavaScript任务间执行，页面就不会变卡顿啦~